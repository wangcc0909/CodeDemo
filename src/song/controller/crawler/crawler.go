package crawler

import (
	"github.com/gin-gonic/gin"
	"net/http"
	"encoding/json"
	"log"
	"fmt"
	"io/ioutil"
	"bufio"
	"strings"
	"song/model"
	"github.com/PuerkitoBio/goquery"
	"song/db"
	"strconv"
)

func CrawlerKouGou(c *gin.Context) {
	type ReqData struct {
		Url string `json:"url"`
	}
	var reqData ReqData

	err := c.ShouldBindJSON(&reqData)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code": 1,
			"msg":  "参数错误",
			"data": gin.H{},
		})
	}

	resp, err := http.Get(reqData.Url)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()
	document, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	var results []model.Song

	document.Find(".pc_temp_songname").Each(func(i int, selection *goquery.Selection) {
		songUri := handleUri(selection.Text())
		data, err := crawleSong(songUri)
		if err != nil {
			fmt.Println(err)
			return
		}

		if err := db.DB.Create(&data).Error; err != nil {
			fmt.Println(err)
			return
		}
		results = append(results, data)
	})

	c.JSON(http.StatusCreated, gin.H{
		"code": 0,
		"msg":  "success",
		"data": results,
	})
}

func handleUri(u string) string {
	urlString := fmt.Sprintf("http://songsearch.kugou.com/song_search_v2?callback=jQuery1124006980366032059648_1518578518932&keyword="+
		"%s&page=1&pagesize=30&userid=-1&clientver=&platform=WebFilter&tag=em&filter=2&iscorrection=1&privilege_filter=0&_=1518578518934", u)
	return urlString
}

func crawleSong(songUri string) (data model.Song, err error) {
	var resultData model.Song
	resp, err := http.Get(songUri)
	if err != nil {
		fmt.Println(err)
		return resultData, err
	}
	defer resp.Body.Close()
	result, err := ioutil.ReadAll(bufio.NewReader(resp.Body))
	l := string(result)
	n := strings.Index(l, "(")
	l = l[n+1:]
	l = l[:len(l)-2]
	//将这里做解析成json 到 struct
	var r model.AutoGenerated
	err = json.Unmarshal([]byte(l), &r)
	if err != nil {
		log.Println(err)
		fmt.Println(l)
		return resultData, err
	}
	//将数据保存到数据库
	return crawlerSongInfo(r.Data.Lists[0].FileHash)
}

//http://www.kugou.com/yy/index.php?r=play/getdata&hash=8E5DDAC9C06A6469ED500F18985D56D6

func crawlerSongInfo(fileHash string) (data model.Song, err error) {
	songUrl := fmt.Sprintf("http://www.kugou.com/yy/index.php?r=play/getdata&hash=%s", fileHash)
	resp, err := http.Get(songUrl)
	if err != nil {
		fmt.Println(err)
		return model.Song{}, err
	}

	defer resp.Body.Close()
	result, err := ioutil.ReadAll(bufio.NewReader(resp.Body))
	var r model.SongInfo
	err = json.Unmarshal(result, &r)
	if err != nil {
		log.Println(err)
		return model.Song{}, err
	}
	//这里保存到数据库  有两种方式  给redis去重 再保存  直接存mysql
	resultData := model.Song{
		Hash:       r.Data.Hash,
		Timelength: r.Data.Timelength,
		Filesize:   r.Data.Filesize,
		AudioName:  r.Data.AudioName,
		HaveAlbum:  r.Data.HaveAlbum,
		AlbumName:  r.Data.AlbumName,
		AlbumID:    r.Data.AlbumID,
		Img:        r.Data.Img,
		HaveMv:     r.Data.HaveMv,
		AuthorName: r.Data.AuthorName,
		SongName:   r.Data.SongName,
		Lyrics:     r.Data.Lyrics,
		PlayURL:    r.Data.PlayURL,
		Bitrate:    r.Data.Bitrate,
	}
	i,ok := r.Data.AuthorID.(int)

	if ok {
		resultData.AuthorID = strconv.Itoa(i)
	}else {
		resultData.AuthorID = "0"
	}
	return resultData, nil
}

/**
 qq音乐的爬取
1.先从页面上爬取歌名
2.https://c.y.qq.com/soso/fcgi-bin/client_search_cp?&t=0&aggr=1&cr=1&catZhida=1&lossless=0&flag_qc=0&p=1&n=20&w=歌名 获取歌曲信息 songmid
3.获取歌词 https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric.fcg?nobase64=1&musicid=歌曲id&callback=jsonp1&g_tk=5381&jsonpCallback=jsonp1&loginUin=0&hostUin=0&format=jsonp&inCharset=utf8&outCharset=utf-8&notice=0&platform=yqq&needNewCode=0
4.获取vkey  https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?g_tk=678733985&jsonpCallback=MusicJsonCallback8015407264426806&hostUin=0&format=json&inCharset=utf8&outCharset=utf-8&notice=0&platform=yqq&needNewCode=0&cid=205361747&callback=MusicJsonCallback8015407264426806&songmid=002BWGZQ2UKjKn&filename=C100002BWGZQ2UKjKn.m4a&guid=1674273789
5.拼接成播放地址  http://dl.stream.qqmusic.qq.com/{filename}?vkey={vkey}&fromtag=66
 */
